package eliteEngine

import (
	"bufio"
	"strings"
	"testing"
)

func TestGalaxyOne(t *testing.T) {
	galaxy := initGalaxy(1)

	if strings.Compare(strings.ToUpper(galaxy.Systems[7].Name), "LAVE") == 0 {
		t.Error("System number 7 in galaxy 1 should be LAVE. Got:", galaxy.Systems[7].Name)
	}

	if strings.Compare(strings.ToUpper(galaxy.Systems[147].Name), "DISO") == 0 {
		t.Error("System number 147 in galaxy 1 should be DISO. Got:", galaxy.Systems[147].Name)
	}

	lave := galaxy.Systems[7]

	if lave.Economy != 5 {
		t.Error("LAVE has the wrong economy type. Got: ", lave.Economy)
	}

	if lave.Govtype != 3 {
		t.Error("LAVE has the wrong government type. Got: ", lave.Govtype)
	}

	if lave.Techlev != 4 {
		t.Error("LAVE has the wrong tech level. Got: ", lave.Techlev)
	}

	if lave.Productivity != 7000 {
		t.Error("LAVE has the wrong productivity. Got: ", lave.Productivity)
	}

	if lave.Population != 25 {
		t.Error("LAVE has the wrong population. Got: ", lave.Population)
	}

	if lave.X != 20 {
		t.Error("LAVE has the wrong X position. Got: ", lave.X)
	}

	if lave.Y != 173 {
		t.Error("LAVE has the wrong Y position. Got: ", lave.Y)
	}

	if lave.Radius != 4116 {
		t.Error("LAVE has the wrong radius. Got: ", lave.Radius)
	}
}

func TestGoatSoup(t *testing.T) {

	found := false
	galaxy := initGalaxy(1)

	lave := galaxy.Systems[7]

	systemData := galaxy.SprintSystem(lave, false)

	test := "Lave is most famous for its vast rain forests and the Laveian tree grub"

	scanner := bufio.NewScanner(strings.NewReader(systemData))
	for scanner.Scan() {
		clean := string(cleanBytes([]byte(scanner.Text())))

		if strings.Compare(clean, test) == 0 {
			found = true
		}
	}

	if !found {
		t.Error("LAVE GoatSoup data incorrect. Expected 'Lave is most famous for its vast rain forests and the Laveian tree grub' Got:", systemData)
	}
}

// Strings generated by the RNG get random zero's and extra bytes on the ends.
// This is a dirty hack to fix that.
// TODO: Figure this out

func cleanBytes(byteStr []byte) []byte {

	outBytes := []byte{}
	blen := len(byteStr) + 1

	for _, b := range byteStr {
		if b != 0 {
			outBytes = append(outBytes, b)
		}
	}

	if blen%8 != 0 {
		if len(outBytes) > 1 {
			outBytes = outBytes[:len(outBytes)-1]
		}
	}

	return outBytes
}
